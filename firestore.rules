/**
 * @fileoverview Firestore Security Rules for ControlSage application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data,
 * combined with role-based access control for administrative functions.
 * Collections like Frameworks and ControlFrameworkMappings are globally readable,
 * but only modifiable by admins. The ruleset leverages path-based ownership
 * and denormalization to avoid costly `get()` operations, ensuring efficient
 * and secure access control.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Only the user themselves can read/write.
 * - /assets: Publicly readable list of assets. Authenticated users can write.
 * - /controls: Publicly readable list of controls. Authenticated users can write.
 * - /auditLogs: Publicly readable list of audit logs.
 * - /users/{userId}/assets/{assetId}: Assets owned by a specific user.
 * - /users/{userId}/controls/{controlId}: Controls owned by a specific user.
 * - /users/{userId}/complianceReports/{complianceReportId}: Compliance reports generated by the user.
 * - /controlImplementations/{controlImplementationId}: Implementations of controls, with denormalized ownerId.
 * - /frameworks/{frameworkId}: Compliance frameworks (globally readable, admin-only writes).
 * - /controlFrameworkMappings/{controlFrameworkMappingId}: Mappings between controls and frameworks (globally readable, admin-only writes).
 * - /roles_admin/{userId}: Documents indicating admin status.
 *
 * Key Security Decisions:
 * - User data is strictly private; users can only access their own data.
 * - Assets and Controls are owned by users and stored under their respective user IDs.
 * - ControlImplementations are secured using a denormalized ownerId field.
 * - Frameworks and ControlFrameworkMappings are globally readable.
 * - Only authenticated admins can modify Frameworks and ControlFrameworkMappings.
 * - Listing user documents is not allowed.
 *
 * Denormalization for Authorization:
 * - ControlImplementation documents contain a denormalized ownerId field to avoid
 *   expensive `get()` calls to determine ownership.
 *
 * Structural Segregation:
 * - Public data (Frameworks, ControlFrameworkMappings) is stored in top-level collections
 *   with permissive read rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles, allowing only the user themselves to access their data.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile.
     *    - request.auth.uid: 'user123'
     *    - request.resource.data.id: 'user123'
     * @allow (get, update, delete) User with ID 'user123' can get, update, and delete their profile.
     *    - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create a profile for 'user123'.
     *    - request.auth.uid: 'user456'
     *    - request.resource.data.id: 'user123'
     * @deny (get, update, delete) User with ID 'user456' cannot get, update, or delete 'user123' profile.
     *    - request.auth.uid: 'user456'
     * @principle Enforces document ownership for user profiles. Validates the ID during creation and ensures immutability on updates.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted.
      allow create: if isSignedIn() && request.auth.uid == userId && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }
    
    match /assets/{assetId} {
      allow get, list: if isSignedIn();
      allow write: if isSignedIn();
    }
    
    match /controls/{controlId} {
      allow get, list: if isSignedIn();
      allow write: if isSignedIn();
    }

    match /auditLogs/{auditLogId} {
      allow get, list: if isSignedIn();
    }

    /**
     * @description Secures assets owned by a specific user, enforcing path-based ownership.
     * @path /users/{userId}/assets/{assetId}
     * @allow (create) User 'user123' can create an asset under their ID.
     *    - request.auth.uid: 'user123'
     * @allow (get, list, update, delete) User 'user123' can access and manage their own assets.
     *    - request.auth.uid: 'user123'
     * @deny (create) User 'user456' cannot create an asset under 'user123's ID.
     *    - request.auth.uid: 'user456'
     * @deny (get, list, update, delete) User 'user456' cannot access or manage 'user123's assets.
     *    - request.auth.uid: 'user456'
     * @principle Enforces path-based ownership for assets.
     */
    match /users/{userId}/assets/{assetId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures controls owned by a specific user, enforcing path-based ownership.
     * @path /users/{userId}/controls/{controlId}
     * @allow (create) User 'user123' can create a control under their ID.
     *    - request.auth.uid: 'user123'
     * @allow (get, list, update, delete) User 'user123' can access and manage their own controls.
     *    - request.auth.uid: 'user123'
     * @deny (create) User 'user456' cannot create a control under 'user123's ID.
     *    - request.auth.uid: 'user456'
     * @deny (get, list, update, delete) User 'user456' cannot access or manage 'user123's controls.
     *    - request.auth.uid: 'user456'
     * @principle Enforces path-based ownership for controls.
     */
    match /users/{userId}/controls/{controlId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures control implementations, using a denormalized ownerId for authorization.
     * @path /controlImplementations/{controlImplementationId}
     * @allow (create) User 'user123' can create a control implementation with their ID as the ownerId.
     *    - request.auth.uid: 'user123'
     *    - request.resource.data.ownerId: 'user123'
     * @allow (get, list, update, delete) User 'user123' can access and manage control implementations they own.
     *    - request.auth.uid: 'user123'
     * @deny (create) User 'user456' cannot create a control implementation with 'user123' as the ownerId.
     *    - request.auth.uid: 'user456'
     *    - request.resource.data.ownerId: 'user123'
     * @deny (get, list, update, delete) User 'user456' cannot access or manage 'user123's control implementations.
     *    - request.auth.uid: 'user456'
     * @principle Enforces ownership for control implementations using a denormalized ownerId.
     */
    match /controlImplementations/{controlImplementationId} {
      allow get: if isSignedIn() && isOwner(resource.data.ownerId);
      allow list: if isSignedIn() && isOwner(resource.data.ownerId);
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.ownerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Secures compliance reports generated by a user, enforcing path-based ownership.
     * @path /users/{userId}/complianceReports/{complianceReportId}
     * @allow (create) User 'user123' can create a compliance report under their ID.
     *    - request.auth.uid: 'user123'
     * @allow (get, list, update, delete) User 'user123' can access and manage their own compliance reports.
     *    - request.auth.uid: 'user123'
     * @deny (create) User 'user456' cannot create a compliance report under 'user123's ID.
     *    - request.auth.uid: 'user456'
     * @deny (get, list, update, delete) User 'user456' cannot access or manage 'user123's compliance reports.
     *    - request.auth.uid: 'user456'
     * @principle Enforces path-based ownership for compliance reports.
     */
    match /users/{userId}/complianceReports/{complianceReportId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows global read access to compliance frameworks, but restricts modification to admins.
     * @path /frameworks/{frameworkId}
     * @allow (get, list) Any user can read the frameworks.
     * @allow (create, update, delete) Only admins can modify frameworks.
     *    - request.auth.uid: (Admin user ID)
     * @principle Allows public read access with admin-only writes for frameworks.
     */
    match /frameworks/{frameworkId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Allows global read access to control framework mappings, but restricts modification to admins.
     * @path /controlFrameworkMappings/{controlFrameworkMappingId}
     * @allow (get, list) Any user can read the control framework mappings.
     * @allow (create, update, delete) Only admins can modify control framework mappings.
     *    - request.auth.uid: (Admin user ID)
     * @principle Allows public read access with admin-only writes for control framework mappings.
     */
    match /controlFrameworkMappings/{controlFrameworkMappingId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

      /**
       * @description Grants admin privileges based on the existence of a document in the /roles_admin/{userId} collection.
       * @path /roles_admin/{userId}
       * @allow (create) Admins can create documents in this collection
       * @allow (get) Anyone can check if a user has admin privileges by checking if the document exists.
       * @principle Checks for document existence to determine admin status.
       */
      match /roles_admin/{userId} {
        allow get: if true; // Anyone can check for admin status
        allow list: if false; // No one can list the admin users
        allow create: if isAdmin(); // Restrict admin creation to existing admins (or a bootstrap process).
        allow update: if false; // Prevent modifications to admin status documents.
        allow delete: if isAdmin() && resource != null; // Only existing admins can delete admin roles.
      }
      
      match /controlAssignments/{assignmentId} {
        allow write: if isSignedIn();
        allow read: if isSignedIn();
      }

  }

  // Helper functions

  /**
   * @description Checks if the user is signed in.
   * @return {boolean} True if the user is signed in, false otherwise.
   */
  function isSignedIn() {
    return request.auth != null;
  }

  /**
   * @description Checks if the user ID matches the authenticated user's ID.
   * @param {string} userId The user ID to check.
   * @return {boolean} True if the user is the owner, false otherwise.
   */
  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

    /**
   * @description Checks if the user ID matches the authenticated user's ID and resource exists.
   * @param {string} userId The user ID to check.
   * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
   */
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }

  /**
   * @description Checks if the user is an admin based on the existence of a document in /roles_admin/{uid}.
   * @return {boolean} True if the user is an admin, false otherwise.
   */
  function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
  }
}

    