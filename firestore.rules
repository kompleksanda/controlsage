/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data and a public-read, owner-write model for shared resources like assets and controls.
 * Data validation is relaxed to allow for rapid prototyping but critical authorization fields are validated.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only to the owning user.
 * - /roles/{roleId}: Stores role definitions. Access is unrestricted for prototyping.
 * - /assets/{assetId}: Stores asset information, readable by everyone, but writable only by the asset owner.
 * - /assetTypes/{assetTypeId}: Stores asset type definitions. Access is unrestricted for prototyping.
 * - /controls/{controlId}: Stores control information, readable by everyone, but writable only by the control owner.
 * - /controlTypes/{controlTypeId}: Stores control type definitions. Access is unrestricted for prototyping.
 * - /controlImplementations/{controlImplementationId}: Stores control implementation data.
 * - /auditLogs/{auditLogId}: Stores audit log data, accessible only to authenticated users.
 *
 * Key Security Decisions:
 * - User listing is explicitly denied.
 * - Read-only collections (roles, assetTypes, controlTypes) have open read access for prototyping.
 * - The default security posture for ambiguous relationships is strict owner-only access.
 * - Denormalization is used to ensure Authorization Independence. Owner IDs are stored directly on documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Defines if the current user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Defines if the current user is the owner of the document based on user ID.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Defines if the current user is the owner of the existing document based on user ID.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their own user document.
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.id: 'user123'
     * @allow (get) User with ID 'user123' can read their own user document.
     *   - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' can update their own user document.
     *   - request.auth.uid: 'user123'
     * @allow (delete) User with ID 'user123' can delete their own user document.
     *   - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create a document for user 'user123'.
     *   - request.auth.uid: 'user456'
     *   - request.resource.data.id: 'user123'
     * @deny (get) User with ID 'user456' cannot read user 'user123' document.
     *   - request.auth.uid: 'user456'
     * @principle Enforces document ownership for reads and writes in the /users collection.
     * @principle Validates that the user ID in the path matches the ID in the document data on creation.
     * @principle Enforces immutability of the 'id' field on updates.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not allowed

      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /roles/{roleId} collection.
     * @path /roles/{roleId}
     * @allow (get) Any user can read role data.
     * @allow (list) Any user can list role data.
     * @principle Allows public read access to role definitions for prototyping.
     */
    match /roles/{roleId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /assets/{assetId} collection.
     * @path /assets/{assetId}
     * @allow (get) Any user can read asset data.
     * @allow (list) Any user can list asset data.
     * @allow (create) Only the asset owner can create an asset. The ownerId field must match the request.auth.uid.
     * @allow (update) Only the asset owner can update an existing asset.
     * @allow (delete) Only the asset owner can delete an existing asset.
     * @deny (create) User creates asset for another user by manipulating ownerId.
     * @principle Allows public read access to asset information but restricts writes to the asset owner.
     */
    match /assets/{assetId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Rules for the /assetTypes/{assetTypeId} collection.
     * @path /assetTypes/{assetTypeId}
     * @allow (get) Any user can read asset type data.
     * @allow (list) Any user can list asset type data.
     * @principle Allows public read access to asset type definitions for prototyping.
     */
    match /assetTypes/{assetTypeId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /controls/{controlId} collection.
     * @path /controls/{controlId}
     * @allow (get) Any user can read control data.
     * @allow (list) Any user can list control data.
     * @allow (create) Only the control owner can create a control.
     * @allow (update) Only the control owner can update an existing control.
     * @allow (delete) Only the control owner can delete an existing control.
     * @principle Allows public read access to control information but restricts writes to the control owner.
     */
    match /controls/{controlId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Rules for the /controlTypes/{controlTypeId} collection.
     * @path /controlTypes/{controlTypeId}
     * @allow (get) Any user can read control type data.
     * @allow (list) Any user can list control type data.
     * @principle Allows public read access to control type definitions for prototyping.
     */
    match /controlTypes/{controlTypeId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /controlImplementations/{controlImplementationId} collection.
     * @path /controlImplementations/{controlImplementationId}
     */
    match /controlImplementations/{controlImplementationId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /auditLogs/{auditLogId} collection.
     * @path /auditLogs/{auditLogId}
     */
    match /auditLogs/{auditLogId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if false;
    }
  }
}